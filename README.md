lab1
Рівень 2.
Варіант 1
Зеник подарував Марічці ділянку городу розміром n на m, поділену на клітинки розміром 1 на 1 метр. У кожній клітинці Марічка посадила гарбузи, щоб дарувати їх залицальникам. Марічка почала садити гарбузи починаючи із верхньої лівої, і при досягненні правої межі - розверталась і рухалась справа наліво, як вказано в прикладі для m x n, де m - кількість рядків, а n - кількість стовпців:

1 2 3 4 8 7 6 5 9 10 11 12 16 15 14 13

Для садіння Марічка вирішила використати робота-садівника, який садить в кожну клітинку задану кількість зернят, які слід вказати як одномірний масив m x n. Якщо Марічка хоче посадити таку кількість гарбузів

1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16

Тоді роботу необхідно подати на всід таку послідовність (маршрут робота не незмінним):

1 2 3 4 8 7 6 5 9 10 11 12 16 15 14 13

Реалізуйте алгоритм, який отримає на вхід масив розміром m та n, в кожній клітинці якого знаходиться бажана кількість гарбузів та поверне одномірний масив, скільки зернин має висаджувати робот при руху згідно маршруту, вказаного в цій задчі (маршрут є незмінним)

Для перевірки виконання роботи реалізованого алгоритму слід використати бібліотеку unittest . Ваш тести мають перевірити роботу алгоритму при значеннях m == n == 5, m =2, n =4, n = 1, m = 6

lab2
Рівень 2
Варіант 1
Love

Андрій закоханий у Ілону. Вони вирішили провести День святого Валентина разом в Ашані, але Андрій, як ми всі знаємо, дуже зайнятий на роботі, тому він не зміг прийти. Тепер якраз Ілона знову наповнена гнівом і готова його вбити. Але є щось, що ви можете зробити.

Андрій розповідає Ілоні, що він програміст-початківець і, як правило, зайнятий вирішенням важливих проблем на проекті. Тож Ілона вирішує перевірити його алгоритмічні навички. Вона пише масив N цілих чисел. Вона дає йому число P і запитує, чи може він знайти три ( тільки три) цілих числа Ai Aj Ak (i ≠ j ≠ k) в масиві, сума якого дорівнює числу P, тобто

Ai + Aj + Ak  = P

Отже, чим швидше Андрій скаже відповідь “Такі числа є” або “Таких чисел немає” тим швидше він отримає поцілунок

Вхідні дані: Масив цілих чисел A1, A2 A3 ……………. AN  Р - Шукане число 

Обмеження 3<= N <= 1000 1<= Ai <= 10^9 де 1<= i <=N 1<= P <= 3*10^9

Приклад

Input 1 2 3 6

Output True

Для перевірки виконання роботи реалізованого алгоритму слід використати бібліотеку unittest

lab3 
Рівень 2
Варіант 1
Для бінарного дерева знайдіть суму всіх листків, які є лівими дітьми.

    3
   / \
  9  20
    /  \
   15   7
Лівий лист цього дерева - 9 та 15, тому сума лівих листів становить 9 + 15 = 24.

Реалізуйте функцію, яка отримує на вхід кореневий вузол дерева, та повертає значення суми branchSums:

def branchSums(root):
	pass
Вхідні дані: Дерево подається у вигляді вузлів, де кожен вузол має ціле значення. Корінь дерева завжди не є лівим листом

Клас, який описує бінарне дерево (та будь який вузол дерева) має вигляд:

class BinaryTree:
    def __init__(self, value):
        self.value = value
        self.left = None
        self.right = None
Реалізація даної задачі не вимагає написання коду вставки чи виділення елементів з бінарного дерева. У тесті ви можете створити достатню кількість елементів класу BinaryTree наступним чином:

root = BinaryTree(3)
root.left = BinaryTree(9)
root.right = BinaryTree(20)
Вихідні дані: Сума всіх лівих листів у бінарному дереві.

lab4
Рівень 2
Варіант 2
Реалізуйте структуру даних "черга з пріоритетами" на основі бінарного дерева binary tree, в якому батьківський елемент має вищий пріоритет, ніж елемент справа, або нижчий або рівний пріоритет, ніж пріоритет його лівої дитини.

Операції, які підтримує ваша черга:

Вставка елемента з заданим значенням та пріоритетом до черги.
Видалення та повернення елемента з найвищим пріоритетом з черги.
Перегляд черги без її зміни.
Для реалізації такої черги з пріоритетами слід використати окремий клас Node, де кожен елемент буде мати два поля: значення та пріоритет. При вставці елемента до черги, його потрібно розмістити у відповідному порядку з урахуванням пріоритету.

Назва файлу реалізації - binary_tree_priority_queue.py

lab5
Рівень 3
Варіант 4. Знайдіть найкоротший безпечний маршрут у полі з датчиками

Нехай у вас задане прямокутне поле, на якому встановлені датчики в певних місцях. Перетніть його найкоротшим безпечним шляхом, не активуючи датчики.

Прямокутне поле має форму матриці M × N, і нам потрібно знайти найкоротший шлях від будь-якої клітинки в першому стовпці до будь-якої клітинки в останньому стовпці матриці. Датчики позначаються в матриці значенням 0, і всі її вісім суміжних осередків також можуть активувати датчики. Шлях можна побудувати лише з комірок зі значенням 1, і в будь-який момент ми можемо рухатися лише на один крок в одному з чотирьох напрямків. Допустимі ходи:

Вгору: (x, y) -> (x – 1, y)
Ліворуч: (x, y) -> (x, y – 1)
Перейти вниз: (x, y) -> (x + 1, y)
Праворуч: (x, y) -> (x, y + 1)
Наприклад, розглянемо таку матрицю:



Найкоротший безпечний шлях має довжину 11. Безпечний маршрут позначений зеленим кольором:



Для представлення графу слід використати матрицю, який зчитується з файлу input.txt
Алгоритм має вивести довжину найкоротшого шляху, або -1 якщо такого не існує
Результат слід вивести у файл output.txt


lab6
Рівень 2
Державна установа 88899
Код задачi: GOVERN
Для закордонної поїздки вам потрiбно отримати кiлька довiдок вiд держустанови.
Проте, виявилося, що для отримання цих довiдок потрiбнi iншi довiдки, а тi, в свою
чергу, потребують ще iнших довiдок.
На отримання кожної довiдки потрiбно вистояти чергу, тому ви хочете зекономити
час, не стоячи в черзi дарма (якщо ви не будете мати потрiбних довiдок, стоячи в
черзi, вам вiдмовлять у видачi цiєї).
Маючи iнформацiю про те, якi довiдки потрiбнi для яких, визначте оптимальний
порядок отримання усiх довiдок, при якому вам жодного разу не вiдмовлять у
видачi. Якщо таких оптимальних варiантiв кiлька — виведiть будь-який iз них.
Вхiднi данi
Кожен iз N рядкiв вхiдного файлу govern .in мiстить два слова, роздiленi пробiлом
— назва довiдки та довiдка, яку потрiбно отримати перед нею.
• Рядкiв може бути вiд 1 до 100000.
• Слова мають довжину вiд 1 до 50 лiтер i складаються з цифр 0-9 i малих лiтер
латинського алфавiту вiд a до z.
• Якщо для однiєї довiдки потрiбно отримати N iнших, файл мiститиме N рядкiв,
що починатимуться на одне й те саме слово.
• Гарантовано iснує хоча б один порядок отримання довiдок, при якому можна
отримати усi довiдки.
Вихiднi данi
Вихiдний файл govern .out повинен мiстити M рядкiв — назви довiдок в порядку їх
рекомендованого отримання.

Примiтка: Пiсля останнього слова також повинен бути символ переносу рядка (new-
line).

↓ Див. приклади нижче ↓

1

Приклад 1
govern .in
visa foreignpassport
visa hotel
visa bankstatement
bankstatement nationalpassport
hotel creditcard
creditcard nationalpassport
nationalpassport birthcertificate
foreignpassport nationalpassport
foreignpassport militarycertificate
militarycertificate nationalpassport
govern .out
birthcertificate
nationalpassport
militarycertificate
foreignpassport
creditcard
hotel
bankstatement
visa

Приклад 2
govern .in
visa foreignpassport
govern .out
foreignpassport
visa

lab7
Рівень 2
Варіант 1
Створити функцію на мові програмування Python, яка приймає дві стрічки: "haystack" (довільний текст) та "needle" (шукана стрічка). Програма повинна знайти індекси всіх входжень стрічки "needle" в стрічці "haystack" та повернути цей індекс, використовуючи  метод Рабіна-Карпа для пошуку підстрічки у стрічці


lab8
Рівень 2
Варіант 1
До вас звернулась мерія міста Венеції з незвичним проханням. Це місто складається з островів які розділені каналами. Кожен острів має свою унікальну локацію і з'єднаний з іншими островами мостами. Мерія міста хоче провести оптоволоконний інтернет на кожен з островів таким чином, щоб кожен острів був з'єднаний з кожним іншим безпосередньо, або через інші острови. Вам потрібно допомогти порахувати мінімальну довжину кабелів, які потрібно прокласти, щоб відстань між всіма островами була мінімальна.

Вхідні дані:

файл islands.csv, який містить матрицю суміжності, де елемент [i][j] вказує на відстань між островами i та j.
Вихідні дані:

Мінімальна довжина підводних кабелів, які потрібно прокласти.
При виборі алгоритму слід вважати, що кількість островів у місті становить N (1 ≤ N ≤ 100)


lab9
Iндiана Джонс i останнiй прямокутний обхiд
Код задачi: IJONES
В пошуках Святого Грааля Iндiана Джонс зiткнувся з небезпечним випробуванням.
Йому потрiбно пройти крiзь прямокутний коридор, який складається з крихких плит
(пригадайте сцену з фiльму «Iндiана Джонс i останнiй хрестовий похiд»). На кожнiй
плитi написана одна лiтера:

a a a
c a b
d e f

Можна починати з будь-якої плити в найлiвiшому стовпцi. Виходом iз коридору є
верхня права та нижня права плити (для прикладу вище — a та f).
Iндiана спритний, i може переходити не лише на сусiдню плиту, а й перестрибувати
через кiлька плит. Проте, щоб не провалитися крiзь пiдлогу, вiн повинен дотримуватися
таких правил:
1. Пiсля кожного кроку Iндiана повинен опинятися правiше, нiж був перед цим.

a a a
c a b
d e f
2. Завжди можна переходити на одну плиту праворуч.
a a a
c a b
d e f

3. Крiм руху на одну плиту праворуч, можна перестрибувати, проте лише на ту
саму лiтеру. Наприклад, з лiтери a можна перестрибнути на будь-яку iншу
лiтеру a за умови, що ми цим ходом просунемося правiше.

a a a
c a b
d e f

1

Для заданого коридору, пiдрахуйте, скiльки всього iснує способiв пройти його успiшно.
Вхiднi данi
Вхiдний файл ijones .in складається з H + 1 рядкiв.
• Перший рядок мiстить два числа W i H, роздiленi пробiлом: W — ширина
коридору, H — висота коридору, 1  W, H  2000.
• Кожен з наступних H рядкiв мiстить слово довжиною W символiв, яке складається
з малих латинських лiтер вiд a до z.
Вихiднi данi
Вихiдний файл ijones .out повинен мiстити одне цiле число — кiлькiсть рiзних
шляхiв для виходу з коридору.

# Див. приклади нижче #

2

Приклад 1
ijones .in
3 3
aaa
cab
def
ijones .out
5
Пояснення: Iснує 3 варiанти обходу, якщо починати з лiтери a, i по одному варiанту,
якщо починати з лiтери c або d.
Приклад 2
ijones .in
10 1
abcdefaghi
ijones .out
2

Приклад 3
ijones .in
7 6
aaaaaaa
aaaaaaa
aaaaaaa
aaaaaaa
aaaaaaa
aaaaaaa
ijones .out
201684
